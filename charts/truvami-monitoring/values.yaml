nameOverride: ""
fullnameOverride: ""

# Default labels to be applied to all alerts
alertLabels:
  altravis_prod: "false"
  altravis_test: "true"
  code: "SBCC"
  customer: "truvami"

prometheus:
  enableRemoteWriteReceiver: false
  storageSize: "10Gi"
  retention: "10d"
  resources:
    requests:
      cpu: "100m"
      memory: "256Mi"
    limits:
      cpu: "1"
      memory: "1Gi"

# Prometheus Rule configuration
prometheusRule:
  enabled: true
  interval: 30s
  labels: {}
  annotations: {}

# Alert Rules Configuration
# Each alert rule can be individually enabled/disabled and have configurable severity levels
alerts:
  # Deployment Version Monitoring
  deploymentVersions:
    enabled: true
    multipleVersions:
      enabled: true
      severity: warning
      duration: 5m
    longRunningMismatch:
      enabled: true
      severity: critical
      duration: 15m
    serviceVersionInfo:
      enabled: true
      severity: info
      duration: 1m

  # Service Health Monitoring
  serviceHealth:
    enabled: true
    bridgeDown:
      enabled: true
      severity: critical
      duration: 1m
    bridgeHighErrorRate:
      enabled: true
      severity: major
      duration: 2m
      threshold: 0.1

  # Device Battery Monitoring
  deviceBattery:
    enabled: true
    criticallyLow:
      enabled: true
      severity: minor
      duration: 1m
      threshold: 2.5
    veryLow:
      enabled: true
      severity: warning
      duration: 5m
      threshold: 2.8

  # Device Duty Cycle Monitoring
  # Monitors duty cycle events - flags sent by device when approaching 1% airtime limit
  deviceDutyCycle:
    enabled: true
    highDutyCycle:
      enabled: true
      severity: warning
      duration: 1h
      threshold: 10  # Alert when duty cycle count > 10 in 24 hours - indicates too frequent uplinks
    excessiveDutyCycle:
      enabled: true
      severity: critical
      duration: 1h
      threshold: 20  # Alert when duty cycle count > 20 in 24 hours - critical misconfiguration

  # Device Health Monitoring
  deviceHealth:
    enabled: true
    excessiveUplinks:
      enabled: true
      severity: major
      duration: 1h
      threshold: 240  # Alert when device sends more than 240 uplinks per day
    # Add other device health alerts here as needed

  signalQuality:
    enabled: false

  # Kafka Monitoring
  kafka:
    enabled: true
    # Add kafka alerts configuration here

  # Database Monitoring
  database:
    enabled: true
    # Add database alerts configuration here

  # Gateway Monitoring
  gateway:
    enabled: true
    # Add gateway alerts configuration here

  # API Monitoring
  api:
    enabled: true
    grpcValidationErrors:
      enabled: true
      severity: major
      duration: 2m
      threshold: 0.1
    deviceNotFoundErrors:
      enabled: true
      severity: major
      duration: 2m
      threshold: 0.1
    webhookErrors:
      enabled: true
      severity: major
      duration: 2m
      threshold: 0.1
    authErrors:
      enabled: true
      severity: major
      duration: 2m
    securityErrors:
      enabled: true
      severity: major
      duration: 1m
      threshold: 0.5
    performanceIssues:
      enabled: true
      severity: minor
      duration: 5m

  # Bridge Consumer Monitoring
  bridgeConsumer:
    enabled: true
    # Add bridge consumer alerts configuration here

  # Siren Monitoring
  siren:
    enabled: true
    # Add siren alerts configuration here

  # Authentication Monitoring
  authentication:
    enabled: true
    # Add authentication alerts configuration here

  # Integration Monitoring
  integration:
    enabled: true
    # Add integration alerts configuration here

# Global alert defaults that can be overridden per alert
alertDefaults:
  severityLevels:
    info: info
    warning: warning
    minor: minor
    major: major
    critical: critical

# Watchdog configuration
watchdog:
  # Webhook URL for watchdog heartbeat (e.g., UptimeRobot heartbeat URL)
  # Set to empty string to disable webhook_url annotation
  webhookUrl: ""

# AlertManager configuration
alertmanager:
  enabled: true

  # Resource configuration for Alertmanager
  resources:
    requests:
      cpu: "50m"
      memory: "128Mi"
    limits:
      cpu: "500m"
      memory: "512Mi"

  # Global configuration
  global:
    smtp_smarthost: "localhost:587"
    smtp_from: "alertmanager@truvami.com"
    smtp_auth_username: ""
    smtp_auth_password: ""
    # Global resolution timeout - how long to wait before an alert is declared resolved if it's not updated
    resolve_timeout: "5m"
    # HTTP configuration for webhooks
    http_config:
      follow_redirects: true
      enable_http2: true

  # Routing configuration
  route:
    # Default receiver for all alerts
    receiver: "default-receiver"
    # Group alerts by these labels
    group_by: ["alertname", "cluster", "service"]
    # How long to initially wait to send a notification for a group of alerts
    group_wait: "10s"
    # How long to wait before sending another notification about new alerts added to a group
    group_interval: "5m"
    # How long to wait before re-sending a notification
    repeat_interval: "12h"
    # Sub-routes for specific alert handling
    routes:
      # Critical alerts route
      - match:
          severity: "critical"
        receiver: "critical-alerts"
        group_wait: "0s"
        group_interval: "1m"
        repeat_interval: "1h"

      # Watchdog alerts route
      - match:
          alertname: "Watchdog"
        receiver: "watchdog-heartbeat"
        group_wait: "0s"
        group_interval: "1m"
        repeat_interval: "5m"

      # OpsGenie route for production alerts
      - match_re:
          environment: "prod|production"
        receiver: "opsgenie-production"
        group_wait: "5s"
        repeat_interval: "5m"

  # Notification receivers
  receivers:
    # Default receiver
    default:
      enabled: true
      webhook:
        enabled: false
        url: ""
        send_resolved: true
        title: "Truvami Alert: {{ .GroupLabels.alertname }}"
        text: "{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}"

    # Critical alerts receiver
    critical:
      enabled: true
      # Multiple notification channels for critical alerts
      webhook:
        enabled: false
        url: ""
      slack:
        enabled: false
        webhook_url: ""
        channel: "#critical-alerts"
        title: "ðŸš¨ CRITICAL: {{ .GroupLabels.alertname }}"
        text: "{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}"

    # OpsGenie receiver for production alerts
    opsgenie:
      enabled: false
      api_key: ""  # Set your OpsGenie API key here (or use secret reference)
      api_url: "https://api.opsgenie.com/"
      # Teams to notify
      teams: []
      # Responders configuration
      responders:
        - type: "team"
          name: "DevOps"
        - type: "user"
          username: "on-call-engineer"
      # Priority mapping
      priority: "{{ if eq .GroupLabels.severity \"critical\" }}P1{{ else if eq .GroupLabels.severity \"major\" }}P2{{ else }}P3{{ end }}"
      # Message configuration
      message: "{{ .GroupLabels.alertname }}: {{ .GroupLabels.instance }}"
      description: "{{ range .Alerts }}{{ .Annotations.description }}{{ end }}"
      # Additional details
      details:
        cluster: "{{ .GroupLabels.cluster }}"
        service: "{{ .GroupLabels.service }}"
        environment: "{{ .GroupLabels.environment }}"
        runbook: "{{ .CommonAnnotations.runbook_url }}"

    # Slack receiver
    slack:
      enabled: false
      webhook_url: ""  # Set your Slack webhook URL here
      channel: "#alerts"
      username: "AlertManager"
      icon_emoji: "ðŸš¨"
      title: "{{ if eq .Status \"firing\" }}ðŸ”´{{ else }}ðŸŸ¢{{ end }} {{ .GroupLabels.alertname }}"
      text: "{{ range .Alerts }}{{ .Annotations.summary }}{{ if .Annotations.description }}\n{{ .Annotations.description }}{{ end }}{{ end }}"
      # Color coding based on severity
      color: "{{ if eq .GroupLabels.severity \"critical\" }}danger{{ else if eq .GroupLabels.severity \"major\" }}warning{{ else }}good{{ end }}"

    # Email receiver
    email:
      enabled: false
      to: "alerts@truvami.com"
      from: "alertmanager@truvami.com"
      subject: "[{{ .Status | toUpper }}] {{ .GroupLabels.alertname }} ({{ .GroupLabels.cluster }})"
      body: |
        {{ range .Alerts }}
        **Alert:** {{ .Annotations.summary }}
        **Description:** {{ .Annotations.description }}
        **Severity:** {{ .Labels.severity }}
        **Cluster:** {{ .Labels.cluster }}
        **Service:** {{ .Labels.service }}
        **Started:** {{ .StartsAt }}
        {{ if .Labels.runbook_url }}**Runbook:** {{ .Labels.runbook_url }}{{ end }}
        {{ end }}

    # PagerDuty receiver (optional)
    pagerduty:
      enabled: false
      routing_key: ""  # Set your PagerDuty integration key
      description: "{{ .GroupLabels.alertname }}: {{ .GroupLabels.instance }}"
      severity: "{{ .GroupLabels.severity }}"
      client: "Truvami AlertManager"
      client_url: "{{ .ExternalURL }}"
      details:
        cluster: "{{ .GroupLabels.cluster }}"
        service: "{{ .GroupLabels.service }}"
        environment: "{{ .GroupLabels.environment }}"

    # Microsoft Teams receiver (optional)
    teams:
      enabled: false
      webhook_url: ""  # Set your Teams webhook URL
      title: "{{ .GroupLabels.alertname }}"
      summary: "{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}"

    # Discord receiver (optional)
    discord:
      enabled: false
      webhook_url: ""  # Set your Discord webhook URL
      title: "{{ .GroupLabels.alertname }}"
      message: "{{ range .Alerts }}{{ .Annotations.summary }}{{ end }}"

  # Inhibition rules - suppress notifications for certain combinations
  inhibit_rules:
    # Suppress warning alerts when critical alerts are firing for the same service
    - source_matchers:
        - severity="critical"
      target_matchers:
        - severity=~"warning|minor"
      equal:
        - service
        - cluster

    # Suppress all alerts when service is in maintenance
    - source_matchers:
        - maintenance="true"
      target_matchers:
        - service=~".*"
      equal:
        - service

  # Silence configuration
  silences:
    # Default silence duration
    default_duration: "1h"
    # Maximum silence duration
    max_duration: "24h"

  # Secret references for sensitive data
  secrets:
    # Reference to secret containing OpsGenie API key
    opsgenie_api_key:
      name: "truvami-monitoring-secrets"
      key: "opsgenie-api-key"

    # Reference to secret containing Slack webhook URL
    slack_webhook_url:
      name: "truvami-monitoring-secrets"
      key: "slack-webhook-url"

    # Reference to secret containing SMTP credentials
    smtp_auth_password:
      name: "truvami-monitoring-secrets"
      key: "smtp-password"

# Dashboard configuration
dashboards:
  enabled: true
  annotations:
    k8s-sidecar-target-directory: "/tmp/dashboards"

  # Jsonnet-based dashboard generation
  # =================================
  # Dashboards are built from Jsonnet sources in /dashboards/src/
  #
  # Development workflow:
  # 1. Edit dashboard sources: /dashboards/src/*.jsonnet
  # 2. Build dashboards: make build-dashboards
  # 3. Generated files are created in: charts/truvami-monitoring/dashboards-generated/
  # 4. Helm automatically includes generated files as ConfigMaps
  #
  # See docs/dashboard-development.md for detailed guide

  # Legacy dashboards - for backwards compatibility only
  # Use Jsonnet approach for all new dashboards
  general: {}
    # Example legacy dashboard:
    # old-dashboard:
    #   title: "Legacy Dashboard"
    #   panels: [...]

grafana:
  enabled: false

  ## Grafana's SMTP configuration
  ## NOTE: To enable, grafana.ini must be configured with smtp.enabled
  ## ref: http://docs.grafana.org/installation/configuration/#smtp
  smtp:
    # `existingSecret` is a reference to an existing secret containing the smtp configuration
    # for Grafana.
    existingSecret: ""
    userKey: "user"
    passwordKey: "password"

  ## Configure grafana datasources
  ## ref: http://docs.grafana.org/administration/provisioning/#datasources
  ##
  datasources:
    "datasources.yaml":
      apiVersion: 1
      datasources:
        - name: Prometheus
          type: prometheus
          url: http://prometheus-operated:9090
          access: proxy
          isDefault: true

  sidecar:
    dashboards:
      enabled: true

  ingress:
    enabled: false
    className: ""
    annotations:
      nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
      nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
      nginx.ingress.kubernetes.io/server-snippets: |
        location / {
          proxysetheader Upgrade $httpupgrade;
          proxyhttpversion 1.1;
          proxysetheader X-Forwarded-Host $httphost;
          proxysetheader X-Forwarded-Proto $scheme;
          proxysetheader X-Forwarded-For $remoteaddr;
          proxysetheader Host $host;
          proxysetheader Connection "upgrade";
          proxycachebypass $httpupgrade;
          }
    hosts:
      - host: chart-example.local
        paths:
          - path: /
            pathType: ImplementationSpecific
    tls: []
    #  - secretName: chart-example-tls
    #    hosts:
    #      - chart-example.local
